{"version":3,"sources":["lazy.js"],"names":[],"mappings":";AAAA","file":"lazy.min.js","sourcesContent":["/* exported yall */\n\n/**\n * yall.js version 2.2.0\n * Yet Another Lazy loader\n **/\n\n// The eponymous function\nwindow.yall = function (userOptions) {\n  \"use strict\";\n\n  // This function handles the lazy loading of elements. It's kicked off by the\n  // scroll handlers/intersection observers further down.\n  let yallLoad = function(element) {\n    // Lazy load <img> elements\n    if (element.tagName === \"IMG\") {\n      let parentElement = element.parentNode;\n\n      // Is the parent element a <picture>?\n      if (parentElement.tagName === \"PICTURE\") {\n        [].slice.call(parentElement.querySelectorAll(\"source\")).forEach(source => yallFlipDataAttrs(source));\n      }\n\n      yallFlipDataAttrs(element);\n    }\n\n    // Lazy load <video> elements\n    if (element.tagName === \"VIDEO\") {\n      [].slice.call(element.querySelectorAll(\"source\")).forEach(source => yallFlipDataAttrs(source));\n\n      // We didn't need this before, but with the addition of lazy loading\n      // `poster` images, we need to run the flip attributes function on the\n      // video element itself so we can trigger lazy loading behavior on those.\n      yallFlipDataAttrs(element);\n\n      if (element.autoplay === true) {\n        element.load();\n      }\n    }\n\n    // Lazy load <iframe> elements\n    if (element.tagName === \"IFRAME\") {\n      element.src = element.dataset.src;\n      element.removeAttribute(\"data-src\");\n    }\n\n    // Lazy load CSS background images\n    if (element.classList.contains(options.lazyBackgroundClass)) {\n      element.classList.remove(options.lazyBackgroundClass);\n      element.classList.add(options.lazyBackgroundLoaded);\n    }\n  };\n\n  // Added because there was a number of patterns like this peppered throughout\n  // the code. This just flips all the data- attrs on an element (after checking\n  // to make sure the data attr is in a whitelist to avoid changing *all* of them)\n  let yallFlipDataAttrs = function(element) {\n    for (let dataAttribute in element.dataset) {\n      if (env.acceptedDataAttributes.indexOf(`data-${dataAttribute}`) !== -1) {\n        element.setAttribute(dataAttribute, element.dataset[dataAttribute]);\n        element.removeAttribute(`data-${dataAttribute}`);\n      }\n    }\n  };\n\n  // When intersection observer is unavailable, this function is bound to scroll\n  // (and other) event handlers to load images the \"old\" way.\n  let yallBack = function() {\n    let active = false;\n\n    if (active === false && lazyElements.length > 0) {\n      active = true;\n\n      setTimeout(() => {\n        lazyElements.forEach(lazyElement => {\n          if (lazyElement.getBoundingClientRect().top <= (window.innerHeight + options.threshold) && lazyElement.getBoundingClientRect().bottom >= -(options.threshold) && getComputedStyle(lazyElement).display !== \"none\") {\n            if (options.idlyLoad === true && env.idleCallbackSupport === true) {\n              requestIdleCallback(() => {\n                yallLoad(lazyElement);\n              }, idleCallbackOptions);\n            } else {\n              yallLoad(lazyElement);\n            }\n\n            lazyElement.classList.remove(options.lazyClass);\n            lazyElements = lazyElements.filter(element => element !== lazyElement);\n          }\n        });\n\n        active = false;\n\n        if (lazyElements.length === 0 && options.observeChanges === false) {\n          env.eventsToBind.forEach(eventPair => eventPair[0].removeEventListener(eventPair[1], yallBack));\n        }\n      }, options.throttleTime);\n    }\n  };\n\n  const env = {\n    intersectionObserverSupport: \"IntersectionObserver\" in window && \"IntersectionObserverEntry\" in window && \"intersectionRatio\" in window.IntersectionObserverEntry.prototype,\n    mutationObserverSupport: \"MutationObserver\" in window,\n    idleCallbackSupport: \"requestIdleCallback\" in window,\n    ignoredImgAttributes: [\"data-src\", \"data-sizes\", \"data-media\", \"data-srcset\", \"src\", \"srcset\"],\n    acceptedDataAttributes: [\"data-src\", \"data-sizes\", \"data-media\", \"data-srcset\", \"data-poster\"],\n    eventsToBind: [\n      [document, \"scroll\"],\n      [document, \"touchmove\"],\n      [window, \"resize\"],\n      [window, \"orientationchange\"]\n    ]\n  };\n\n  const options = {\n    lazyClass: \"lazy\",\n    lazyBackgroundClass: \"lazy-bg\",\n    lazyBackgroundLoaded: \"lazy-bg-loaded\",\n    throttleTime: 200,\n    idlyLoad: false,\n    idleLoadTimeout: 100,\n    threshold: 200,\n    observeChanges: false,\n    observeRootSelector: \"body\",\n    mutationObserverOptions: {\n      childList: true\n    },\n    ...userOptions\n  };\n  const selectorString = `img.${options.lazyClass},video.${options.lazyClass},iframe.${options.lazyClass},.${options.lazyBackgroundClass}`;\n  const idleCallbackOptions = {\n    timeout: options.idleLoadTimeout\n  };\n\n  let lazyElements = [].slice.call(document.querySelectorAll(selectorString));\n\n  if (env.intersectionObserverSupport === true) {\n    var intersectionListener = new IntersectionObserver((entries, observer) => {\n      entries.forEach(entry => {\n        if (entry.isIntersecting === true || entry.intersectionRatio > 0) {\n          let element = entry.target;\n\n          if (options.idlyLoad === true && env.idleCallbackSupport === true) {\n            requestIdleCallback(() => yallLoad(element), idleCallbackOptions);\n          } else {\n            yallLoad(element);\n          }\n\n          element.classList.remove(options.lazyClass);\n          observer.unobserve(element);\n          lazyElements = lazyElements.filter(lazyElement => lazyElement !== element);\n        }\n      });\n    }, {\n      rootMargin: `${options.threshold}px 0%`\n    });\n\n    lazyElements.forEach(lazyElement => intersectionListener.observe(lazyElement));\n  } else {\n    env.eventsToBind.forEach(eventPair => eventPair[0].addEventListener(eventPair[1], yallBack));\n    yallBack();\n  }\n\n  if (env.mutationObserverSupport === true && options.observeChanges === true) {\n    new MutationObserver(mutations => mutations.forEach(() => {\n      [].slice.call(document.querySelectorAll(selectorString)).forEach(newElement => {\n        if (lazyElements.indexOf(newElement) === -1) {\n          lazyElements.push(newElement);\n\n          if (env.intersectionObserverSupport === true) {\n            intersectionListener.observe(newElement);\n          } else {\n            yallBack();\n          }\n        }\n      });\n    })).observe(document.querySelector(options.observeRootSelector), options.mutationObserverOptions);\n  }\n};\ndocument.addEventListener(\"DOMContentLoaded\", yall);\n"]}